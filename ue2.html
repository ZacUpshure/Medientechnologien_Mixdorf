<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="format.css">
<style type="text/css">
        /* <!--
                 a:link {font-family:Arial;        font-size:10pt;        text-decoration:none;}
                a:visited {font-family:Arial; font-size:10pt; text-decoration:none;}
                a:hover {color:#FF3333; text-decoration:none; font-weight:normal; font-size:10pt;}
        //--> */
</style>
</head>

<body>

<iframe src="oben.html" width="800" height="120" name="IFrame3" id="IFrame3" scrolling="no" frameborder="0">
         <p>Ihr Browser kann leider keine eingebe5tteten Frames anzeigen:Sie k&ouml;nnen die eingebettete Seite &uuml;ber den
         folgenden.</p>
</iframe>

<h2>Uebung 2</h2>
<br><h3>Aufgabe 1 - 1.1</h3>
<p>Bescheibung</p>
        <p>Nun lies die Bilder mit bmp_io ein und erklaere die Angaben im Header, die auf der Konsole ausgegeben werden! Wie erklaert sich die Dateigroesse für die beiden Dateien?</p>
        
<table><tr>
<td><img src="./pics/nature_06.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
<td><img src="./pics/manmade_06.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
<td><img src="./pics/grating_H6.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
<td><img src="./pics/grating_V2.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
</tr></table>
        
<p>Loesung</p>
        <p>Headerangaben: </p>
        <p>Grating_h6 | Grating_v2</p>
        <p>Dateigroesse: 921.654 bytes</p>
        <p>Bits pro Pixel 24</p>
        <p>Hoehe: 640</p>
        <p>Breite: 480</p>
        <br>
        <p>manmade_06 | nature_06</p>
        <p>Dateigroesse: 1.555.254 bytes</p>
        <p>Bits pro Pixel 24</p>
        <p>Hoehe: 960</p>
        <p>Breite: 540</p>
        
<p>Loesung</p>

<br><h3>Aufgabe 2 - 2.1</h3>
<p>Bescheibung</p>
<p>Loesung</p>
     <code>
     try (FileOutputStream fosh = new FileOutputStream("horizontal.txt");<br>
     OutputStreamWriter oswh = new OutputStreamWriter(fosh, "US-ascii");<br>
     BufferedWriter bwh = new BufferedWriter(oswh)) {<br>
     <br>
    // BGR schreiben horizontal 2.1.<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int rAmount = bmp.image.getRgbPixel(x, 0).r;<br>
        int gAmount = bmp.image.getRgbPixel(x, 0).g;<br>
        int bAmount = bmp.image.getRgbPixel(x, 0).b;<br>
        <br>
        bwh.write(rAmount + " " + gAmount + " " + bAmount);<br>
        bwh.newLine();<br>
    }<br>
<br>
} catch (IOException e) {<br>
    e.printStackTrace();<br>
}<br>
<br>
try (FileOutputStream fosv = new FileOutputStream("vertikal.txt");<br>
     OutputStreamWriter oswv = new OutputStreamWriter(fosv, "US-ascii");<br>
     BufferedWriter bwv = new BufferedWriter(oswv)) {<br>
        <br>
    // BGR schreiben vertikal 2.1.<br>
    for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
        int rAmount = bmp.image.getRgbPixel(0, y).r;<br>
        int gAmount = bmp.image.getRgbPixel(0, y).g;<br>
        int bAmount = bmp.image.getRgbPixel(0, y).b;<br>
        <br>
        bwv.write(rAmount + " " + gAmount + " " + bAmount);<br>
        bwv.newLine();<br>
    }<br>
<br>
} catch (IOException e) {<br>
    e.printStackTrace();<br>
}<br>
</code>
       <p>Grating_V2 Ascii horizontal Ergebnisausschnitt:</p> 
       <br>
       <p>Grating_V2 Ascii vertikal Ergebnisausschnitt:</p>
       <br>
       <p>Grating_H6 Ascii horizontal Ergebnisausschnitt:</p>
       <br>
       <p>Grating_H6 Ascii vertikal Ergebnisausschnitt:</p>

<br><h3>Aufgabe 2 - 2.2</h3>
<p>Beschreibung</p>
        <p>Auch bei der Bildabtastung muss das sogenannte Abtasttheorem eingehalten werden. Wie lautet es und wie laesst sich der Grenzfall, für den es gerade noch gilt, illustrieren
(Zeichnung !)?</p>
<p>Loesung</p>
        <p>Das Abtasttheorem, auch als Nyquist-Shannon-Abtasttheorem bekannt, 
                besagt, dass für eine zuverlässige Wiederherstellung eines Signals 
                aus seinen Abtastwerten die Abtastfrequenz mindestens doppelt so 
                hoch sein muss wie die höchste Frequenzkomponente im Signal.
        </p>
        <br>
        <p>(f_a >= 2 * f_max), sonst kann aliasing auftauchen</p>
        <img src="./pics/2_2_sinus.png" alt="Penguins auf dem Eis" width="350" height="300">
        <p>In diesem Plot repräsentieren die "x"-Symbole die Abtastpunkte des Sinussignals. 
                Du kannst sehen, dass die Abtastpunkte genau auf der Sinuskurve liegen. 
                Dies entspricht der optimalen Abtastung gemäß dem Abtasttheorem.
                <br>
                Wenn jedoch die Abtastfrequenz leicht unter 2 * f_max liegt, 
                führt dies zu Alias-Effekten. In diesem Fall würden die Abtastpunkte nicht 
                mehr genau auf der Sinuskurve liegen und es würde zu Verzerrungen oder falscher 
                Darstellung des Signals kommen.
        </p>

<br><h3>Aufgabe 2 - 2.3</h3>
<p>Beschreibung</p>
        <p>Erzeuge aus deinen eigenen Farbbildern Graustufen-Bilder. 
           Dazu muss der Helligkeitswert Y aus den RGB-Werten errechnet werden. 
           Es gibt dafür verschiedene Ansätze.
           <br>
           Nutze die Formel Y= 0,3 x R + 0,6 x G + 0,1 x B, die die Helligkeitsempfindlichkeit 
           des Auges annähert. Mit diesem Y-Wert wird dann die R, G und B-Information überschrieben.
           Speichere die Graustufenbilder ab.
        </p>
<p>Loesung</p>
        <table><tr>
                <td><img src="./manmade_06-modified.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
                <td><img src="./nature_06-modified.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
        </tr></table>
        <code>
    for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int rAmount = bmp.image.getRgbPixel(x, y).r;<br>
        int gAmount = bmp.image.getRgbPixel(x, y).g;<br>
        int bAmount = bmp.image.getRgbPixel(x, y).b;<br>
        <br>
        int grey = (int) Math.round(0.3 * rAmount + 0.6 * gAmount + 0.1 * bAmount);<br>
        <br>
        PixelColor greyPixel = new PixelColor(grey, grey, grey);<br>
        bmp.image.setRgbPixel(x, y, greyPixel);<br>
    }<br>
}<br>
</code>

<br><h3>Aufgabe 3 - 3.1</h3>
<p>Loesung</p>

</body>
</html>
