<html>
<head>
<title></title>
<link rel="stylesheet" type="text/css" href="format.css">
<style type="text/css">
        /* <!--
                 a:link {font-family:Arial;        font-size:10pt;        text-decoration:none;}
                a:visited {font-family:Arial; font-size:10pt; text-decoration:none;}
                a:hover {color:#FF3333; text-decoration:none; font-weight:normal; font-size:10pt;}
        //--> */
</style>
</head>

<body>

<iframe src="oben.html" width="800" height="120" name="IFrame3" id="IFrame3" scrolling="no" frameborder="0">
         <p>Ihr Browser kann leider keine eingebe5tteten Frames anzeigen:Sie k&ouml;nnen die eingebettete Seite &uuml;ber den
         folgenden.</p>
</iframe>

<h2>Uebung 2</h2>
<br><h3>Aufgabe 1 - 1.1</h3>
<p>Bescheibung</p>
        <p>Nun lies die Bilder mit bmp_io ein und erklaere die Angaben im Header, die auf der Konsole ausgegeben werden! Wie erklaert sich die Dateigroesse für die beiden Dateien?</p>
        
<table><tr>
<td><img src="./pics/nature_06.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
<td><img src="./pics/manmade_06.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
<td><img src="./pics/grating_H6.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
<td><img src="./pics/grating_V2.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
</tr></table>
        
<p>Loesung</p>
        <p>Headerangaben: </p>
        <p>Grating_h6 | Grating_v2</p>
        <p>Dateigroesse: 921.654 bytes</p>
        <p>Bits pro Pixel 24</p>
        <p>Hoehe: 640</p>
        <p>Breite: 480</p>
        <br>
        <p>manmade_06 | nature_06</p>
        <p>Dateigroesse: 1.555.254 bytes</p>
        <p>Bits pro Pixel 24</p>
        <p>Hoehe: 960</p>
        <p>Breite: 540</p>
        
<p>Loesung</p>

<br><h3>Aufgabe 2 - 2.1</h3>
<p>Bescheibung</p>
<p>Loesung</p>
     <code>
     try (FileOutputStream fosh = new FileOutputStream("horizontal.txt");<br>
     OutputStreamWriter oswh = new OutputStreamWriter(fosh, "US-ascii");<br>
     BufferedWriter bwh = new BufferedWriter(oswh)) {<br>
     <br>
    // BGR schreiben horizontal 2.1.<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int rAmount = bmp.image.getRgbPixel(x, 0).r;<br>
        int gAmount = bmp.image.getRgbPixel(x, 0).g;<br>
        int bAmount = bmp.image.getRgbPixel(x, 0).b;<br>
        <br>
        bwh.write(rAmount + " " + gAmount + " " + bAmount);<br>
        bwh.newLine();<br>
    }<br>
<br>
} catch (IOException e) {<br>
    e.printStackTrace();<br>
}<br>
<br>
try (FileOutputStream fosv = new FileOutputStream("vertikal.txt");<br>
     OutputStreamWriter oswv = new OutputStreamWriter(fosv, "US-ascii");<br>
     BufferedWriter bwv = new BufferedWriter(oswv)) {<br>
        <br>
    // BGR schreiben vertikal 2.1.<br>
    for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
        int rAmount = bmp.image.getRgbPixel(0, y).r;<br>
        int gAmount = bmp.image.getRgbPixel(0, y).g;<br>
        int bAmount = bmp.image.getRgbPixel(0, y).b;<br>
        <br>
        bwv.write(rAmount + " " + gAmount + " " + bAmount);<br>
        bwv.newLine();<br>
    }<br>
<br>
} catch (IOException e) {<br>
    e.printStackTrace();<br>
}<br>
</code>
       <p>Grating_V2 Ascii horizontal Ergebnisausschnitt:</p> 
       <br>
       <p>Grating_V2 Ascii vertikal Ergebnisausschnitt:</p>
       <br>
       <p>Grating_H6 Ascii horizontal Ergebnisausschnitt:</p>
       <br>
       <p>Grating_H6 Ascii vertikal Ergebnisausschnitt:</p>

<br><h3>Aufgabe 2 - 2.2</h3>
<p>Beschreibung</p>
        <p>Auch bei der Bildabtastung muss das sogenannte Abtasttheorem eingehalten werden. Wie lautet es und wie laesst sich der Grenzfall, für den es gerade noch gilt, illustrieren
(Zeichnung !)?</p>
<p>Loesung</p>
        <p>Das Abtasttheorem, auch als Nyquist-Shannon-Abtasttheorem bekannt, 
                besagt, dass für eine zuverlässige Wiederherstellung eines Signals 
                aus seinen Abtastwerten die Abtastfrequenz mindestens doppelt so 
                hoch sein muss wie die höchste Frequenzkomponente im Signal.
        </p>
        <br>
        <p>(f_a >= 2 * f_max), sonst kann aliasing auftauchen</p>
        <img src="./pics/2_2_sinus.png" alt="Penguins auf dem Eis" width="350" height="300">
        <p>In diesem Plot repräsentieren die "x"-Symbole die Abtastpunkte des Sinussignals. 
                Du kannst sehen, dass die Abtastpunkte genau auf der Sinuskurve liegen. 
                Dies entspricht der optimalen Abtastung gemäß dem Abtasttheorem.
                <br>
                Wenn jedoch die Abtastfrequenz leicht unter 2 * f_max liegt, 
                führt dies zu Alias-Effekten. In diesem Fall würden die Abtastpunkte nicht 
                mehr genau auf der Sinuskurve liegen und es würde zu Verzerrungen oder falscher 
                Darstellung des Signals kommen.
        </p>

<br><h3>Aufgabe 2 - 2.3</h3>
<p>Beschreibung</p>
        <p>Erzeuge aus deinen eigenen Farbbildern Graustufen-Bilder. 
           Dazu muss der Helligkeitswert Y aus den RGB-Werten errechnet werden. 
           Es gibt dafür verschiedene Ansätze.
           <br>
           Nutze die Formel Y= 0,3 x R + 0,6 x G + 0,1 x B, die die Helligkeitsempfindlichkeit 
           des Auges annähert. Mit diesem Y-Wert wird dann die R, G und B-Information überschrieben.
           Speichere die Graustufenbilder ab.
        </p>
<p>Loesung</p>
        <table><tr>
                <td><img src="./manmade_06-modified.bmp" alt="Koalabaer auf dem Baum" width="350" height="300"></td>
                <td><img src="./nature_06-modified.bmp" alt="Penguins auf dem Eis" width="350" height="300"></td>
        </tr></table>
        <code>
    for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int rAmount = bmp.image.getRgbPixel(x, y).r;<br>
        int gAmount = bmp.image.getRgbPixel(x, y).g;<br>
        int bAmount = bmp.image.getRgbPixel(x, y).b;<br>
        <br>
        int grey = (int) Math.round(0.3 * rAmount + 0.6 * gAmount + 0.1 * bAmount);<br>
        <br>
        PixelColor greyPixel = new PixelColor(grey, grey, grey);<br>
        bmp.image.setRgbPixel(x, y, greyPixel);<br>
    }<br>
}<br>
</code>
      
<br><h3>Aufgabe 2 - 2.4</h3>
<p>Beschreibung</p>
        <p>
                Erkläre, wie bei Bild- und Videoaufnahmen Aliasing entstehen kann. Ähnlich wie bei der 1. Übung am Audiosignal wollen wir auf das Bild ein Down-Sampling anwenden und
                sehen, wann dabei Aliasing auftritt. Beim Audiosignal haben wir jedes zweite Sample verworfen und damit die Abtastfrequenz halbiert. Beim Bild verringern wir die räumliche
                Auflösung, indem wir die Zahl der Bildzeilen bzw. Bildspalten verringern. Dabei wollen wir das Bild allerdings nicht verkleinern - was normalerweise die Folge wäre - sondern einfach
                die ungeradzahligen Spalten durch den Inhalt der geradzahligen Spalten ersetzen, d.h. Spalte 1 wird durch Spalte 0 ersetzt, Spalte 3 durch Spalte 2 etc. und analog für die Zeilen.
                Wenn das Ursprungsbild nun sehr feine Strukturen aufweist, wie in machen Testdateien, können Aliasing-Verzerrungen sichtbar werden. Achte darauf, dass stets Rot, Grün und
                Blau getrennt manipuliert werden müssen.
        </p> 
        <p>
            Aliasing tritt bei Bild- und Videoaufnahmen auf, wenn die Abtastung oder Auflösung des Bildes nicht ausreicht, 
            um feine Details oder Muster mit hoher Frequenz genau darzustellen. Im Zusammenhang mit der Bildverkleinerung 
            tritt Aliasing auf, wenn wir die räumliche Auflösung reduzieren, indem wir die Anzahl der Bildzeilen oder 
            -spalten verringern.    
        </p>
        <p>
            Wenn das ursprüngliche Bild feine Strukturen oder Details mit hoher Frequenz enthält, 
            wie zum Beispiel dünnen Linien oder Mustern, können Aliasing-Verzerrungen sichtbar werden. 
            Dies liegt daran, dass die reduzierte räumliche Auflösung nicht ausreicht, um diese Details genau darzustellen, 
            was zu Artefakten oder Verzerrungen führt. Diese können als gezackte Kanten, Moiré-Muster oder 
            Unschärfeerscheinungen in Erscheinung treten.  
        </p>
<p>Loesung</p>    
        
<br><h3>Aufgabe 2 - 2.5</h3>
<p>Loesung</p>
        <p>downsample bis Moiré-Effekt</p>
        <p>horizontal downsample 2x grating_V2</p>
        <img src="./pics/grating_V2_downsampled_horizontal_2x.bmp" alt="Penguins auf dem Eis" width="350" height="300">
        <p>vertikal downsample 9x grating_H6</p>
        <img src="./pics/grating_H6_downsampled_vertical_9x.bmp" alt="Koalabaer auf dem Baum" width="350" height="300">
        <br>
<code>
for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        // Horizontal<br>
        if (x % 4 != 0) {<br>
            PixelColor pixel = bmp.image.getRgbPixel(x - 1, y);<br>
            bmp.image.setRgbPixel(x, y, pixel);<br>
        }<br>
    }<br>
}<br>
<br>
for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        // Vertikal<br>
        if (y % 2 != 0) {<br>
            PixelColor pixel = bmp.image.getRgbPixel(x, y - 1);<br>
            bmp.image.setRgbPixel(x, y, pixel);<br>
        }<br>
    }<br>
}<br>
   
</code>
        <p>horizontal downsample nature_06 bis signifikanter verlusst an qualität</p>
        <img src="./pics/nature_06_horizontal_downscale.bmp" alt="Koalabaer auf dem Baum" width="350" height="300">

<br><h3>Aufgabe 3 - 3.1 + 3.2</h3>
<p>Loesung</p>
        <img src="./pics/nature_06_bit_reduced.bmp" alt="Koalabaer auf dem Baum" width="350" height="300">
        <br>
<code> 
int reducedBits = 16;<br>
<br>
for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int r = bmp.image.getRgbPixel(x, y).r;<br>
        int g = bmp.image.getRgbPixel(x, y).g;<br>
        int b = bmp.image.getRgbPixel(x, y).b;<br>
<br>
        int rNew = r / reducedBits;<br>
        int gNew = g / reducedBits;<br>
        int bNew = b / reducedBits;<br>
<br>
        PixelColor color = new PixelColor(rNew * reducedBits, gNew * reducedBits, bNew * reducedBits);<br>
        bmp.image.setRgbPixel(x, y, color);<br>
    }<br>
}<br>
</code>
        
<br><h3>Aufgabe 3 - 3.3</h3>
<p>Loesung</p>
int reducedBits = 32;<br>
int bitsPerColor = 8;<br>
<code> 
for (int y = 0; y < bmp.image.getHeight(); y++) {<br>
    for (int x = 0; x < bmp.image.getWidth(); x++) {<br>
        int r = bmp.image.getRgbPixel(x, y).r;<br>
        int g = bmp.image.getRgbPixel(x, y).g;<br>
        int b = bmp.image.getRgbPixel(x, y).b;<br>
<br>
        int rNew = r / reducedBits;<br>
        int gNew = g / reducedBits;<br>
        int bNew = b / reducedBits;<br>
<br>
        rNew = rNew * reducedBits;<br>
        gNew = gNew * reducedBits;<br>
        bNew = bNew * reducedBits;<br>
<br>
        int rDiff = r - rNew;<br>
        int gDiff = g - gNew;<br>
        int bDiff = b - bNew;<br>
<br>
        PixelColor color = new PixelColor(rDiff + 128, gDiff + 128, bDiff + 128);<br>
        bmp.image.setRgbPixel(x, y, color);<br>
    }<br>
}<br>
</code>

        
        
</body>
</html>
